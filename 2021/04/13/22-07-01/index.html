<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><meta name="author" content="JiangHural"><meta name="subtitle" content="你来我往，各凭技艺，<br>人在江湖，奋斗不息。"><meta name="description" content="输出是最好的学习方式"><title>Java刷题(1) | JiangHural</title><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/style.css"><script src="/js/script.js"></script><script src="/js/tocbot.min.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="wrapper"><header><nav class="navbar"><div class="container"><div class="navbar-header header-logo"><a href="/">JiangHu&#39;s Blog</a></div><div class="menu navbar-right"><a class="menu-item" href="/archives">Posts</a> <a class="menu-item" href="/category">Categories</a> <a class="menu-item" href="/tag">Tags</a> <a class="menu-item" href="/about">About</a> <input id="switch_default" type="checkbox" class="switch_default"> <label for="switch_default" class="toggleBtn"></label></div></div></nav><nav class="navbar-mobile" id="nav-mobile"><div class="container"><div class="navbar-header"><div><a href="/">JiangHu&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a></div><div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div></div><div class="menu" id="mobile-menu"><a class="menu-item" href="/archives">Posts</a> <a class="menu-item" href="/category">Categories</a> <a class="menu-item" href="/tag">Tags</a> <a class="menu-item" href="/about">About</a></div></div></nav></header><script>var mobileBtn=function(){var e=document.getElementsByClassName("menu-toggle")[0],t=document.getElementById("mobile-menu");e.classList.contains("active")?(e.classList.remove("active"),t.classList.remove("active")):(e.classList.add("active"),t.classList.add("active"))}</script><div class="main"><div class="container"><div class="post-toc"><div class="tocbot-list"></div><div class="tocbot-list-menu"><a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a> <a onclick="go_top()">Back to top</a> <a onclick="go_bottom()">Go to bottom</a></div></div><script>function expand_toc(){var o=document.querySelector(".tocbot-toc-expand");tocbot.init({tocSelector:".tocbot-list",contentSelector:".post-content",headingSelector:"h1, h2, h3, h4, h5",collapseDepth:6,orderedList:!1,scrollSmooth:!0}),o.setAttribute("onclick","collapse_toc()"),o.innerHTML="Collapse all"}function collapse_toc(){var o=document.querySelector(".tocbot-toc-expand");tocbot.init({tocSelector:".tocbot-list",contentSelector:".post-content",headingSelector:"h1, h2, h3, h4, h5",collapseDepth:1,orderedList:!1,scrollSmooth:!0}),o.setAttribute("onclick","expand_toc()"),o.innerHTML="Expand all"}function go_top(){window.scrollTo(0,0)}function go_bottom(){window.scrollTo(0,document.body.scrollHeight)}document.ready(function(){tocbot.init({tocSelector:".tocbot-list",contentSelector:".post-content",headingSelector:"h1, h2, h3, h4, h5",collapseDepth:1,orderedList:!1,scrollSmooth:!0})})</script><article class="post-wrap"><header class="post-header"><h1 class="post-title">Java刷题(1)</h1><div class="post-meta">Author: <a itemprop="author" rel="author" href="/">JiangHural</a> <span class="post-time">Date: <a href="#">四月 13, 2021&nbsp;&nbsp;22:07:01</a> </span><span class="post-category">Category: <a href="/categories/%E5%88%B7%E9%A2%98/">刷题</a></span></div></header><div class="post-content"><h2 id="210414"><a href="#210414" class="headerlink" title="210414"></a>210414</h2><p><code>sleep()</code>方法（休眠）是线程类（Thread）的静态方法，调用此方***让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态，请参考第66题中的线程状态转换图）。<code>wait()</code>是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的<code>notify()</code>方法（或<code>notifyAll()</code>方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。</p><p>yield()让当前正在运行的线程回到可运行状态，以允许具有相同优先级的其他线程获得运行的机会。因此，使用yield()的目的是让具有相同优先级的线程之间能够适当的轮换执行。但是，实际中无法保证yield()达到让步的目的，因为，让步的线程可能被线程调度程序再次选中</p><blockquote><p>补充一点，应该是让优先级大于等于的其他线程获得同等运行的机会，具体是谁抢到就说不定了。或者说使用yield（）就是使自己和优先级大于等于自己的线程回到同一起跑线，然后就不能保证谁一定跑得快到达终点获得执行权了。</p><p>还记得马老师说过，yiled方法属于高风亮节的行为，这个坑位我不上了，后面跟我同级别的先上厕所。这样比较好记！<br>高优先级的就是你们的县长，县长要上厕所，对不起，你得出来，县长先上，县长上完了，CPU分配到你了，你才能继续拉X。</p></blockquote><hr><p>关于Java内存区域下列说法不正确的有哪些 <strong>BC</strong></p><ul><li>程序计数器是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的信号指示器，每个线程都需要一个独立的程序计数器.</li><li><del>Java虚拟机栈描述的是java方法执行的内存模型，每个方法被执行的时候都会创建一个栈帧，用于存储局部变量表、类信息、动态链接等信息</del></li><li><del>Java堆是java虚拟机所管理的内存中最大的一块，每个线程都拥有一块内存区域，所有的对象实例以及数组都在这里分配内存。</del></li><li>方法区是各个线程共享的内存区域，它用于存储已经被虚拟机加载的常量、即时编译器编译后的代码、静态变量等数据。</li></ul><p>A.程序计数器是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的信号指示器（偏移地址），Java编译过程中产生的字节码有点类似编译原理的指令，程序计数器的内存空间存储的是当前执行的字节码的偏移地址，每一个线程都有一个独立的程序计数器（程序计数器的内存空间是线程私有的），因为当执行语句时，改变的是程序计数器的内存空间，因此它不会发生内存溢出 ，并且程序计数器是jvm虚拟机规范中唯一一个没有规定 OutOfMemoryError 异常 的区域；</p><p>B.java虚拟机栈：线程私有，生命周期和线程一致。描述的是 Java 方法执行的内存模型：每个方法在执行时都会床创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。 没有类信息，类信息是在方法区中</p><p>C.java堆：对于绝大多数应用来说，这块区域是 JVM 所管理的内存中最大的一块。线程共享，主要是存放对象实例和数组</p><p>D.方法区：属于共享内存区域，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><hr><h2 id="210413"><a href="#210413" class="headerlink" title="210413"></a>210413</h2><hr><blockquote><p>在为传统面向对象语言的程序做单元测试的时候,经常用到mock对象。Mock对象通过反射数。请问反射最大程度破坏了面向对象的以下哪个特性？<strong>封装</strong></p></blockquote><ul><li>mock对象：也成为伪对象，在测试中的利用mock对象来代替真实对象，方便测试的进行。</li><li>java的封装性：指的是将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象内部信息，通过该类提供的方法实现对内部信息的操作访问。</li><li>反射机制：在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法;对于任意一个对象，都能够调用它的任意一个方法和属性</li></ul><hr><p>AOP 和 OOP的区别：</p><ol><li>面向方面编程 AOP 偏重业务处理过程的某个步骤或阶段，强调降低模块之间的耦合度，使代码拥有更好的移植性。</li><li>面向对象编程 (oop) 则是对业务分析中抽取的实体进行方法和属性的封装。<br>也可以说 AOP 是面向业务中的动词领域， OOP 面向名词领域。<br>AOP 的一个很重要的特点是源代码无关性，也就是说如果我们的系统中引用了 AOP 组件，即使我们把该组件去掉，系统代码也应该能够编译通过。要实现这一点，可以使用动态 proxy 模式。</li></ol><hr><ul><li>final修饰的成员变量为基本数据类型是，在赋值之后无法改变。当final修饰的成员变量为引用数据类型时，在赋值后其指向地址无法改变，但是对象内容还是可以改变的。</li><li>final修饰的成员变量在赋值时可以有三种方式。1、在声明时直接赋值。2、在构造器中赋值。3、在初始代码块中进行赋值。</li><li>final修饰的方法，不允许被子类覆盖。</li></ul><hr><blockquote><p>哪个修饰符修饰的变量是所有同一个类生成的对象共享的? <strong>static</strong></p></blockquote><ul><li>static修饰某个字段时，肯定会改变字段创建的方式（每个被static修饰的字段对于每一个类来说只有一份存储空间，而非static修饰的字段对于每一个对象来说都有一个存储空间）</li><li>static属性是属于类的，所以对象共同拥有，所以既可以通过类名.变量名进行操作，又可以通过对象名.变量名进行操作</li></ul><hr><ul><li><p>重载的概念是：</p></li><li><p>方法名称相同，参数个数、次序、类型不同</p></li><li><p>因此重载对返回值没有要求，可以相同，也可以不同</p></li><li><p>但是如果参数的个数、类型、次序都相同，方法名也相同，仅返回值不同，则无法构成重载</p></li></ul><hr><blockquote><p>哪些具体实现类可以用于存储键，值对，并且方法调用提供了基本的多线程安全支持：() <strong>HashTable,SynchronizedMap,ConcurrentHashMap</strong></p></blockquote><ul><li><strong>Hashtable</strong>是线程安全的哈希表，它是通过synchronized来保证线程安全的；即，多线程通过同一个“对象的同步锁”来实现并发控制。Hashtable在线程竞争激烈时，效率比较低（此时建议使用ConcurrentHashMap）。当一个线程访问Hashtable的同步方法时，其它线程如果也在访问Hashtable的同步方法时，可能会进入阻塞状态。</li><li><strong>Collections.synchronizedMap</strong>()使用了synchronized同步关键字来保证对Map的操作是线程安全的。</li><li><strong>ConcurrentHashMap</strong>是线程安全的哈希表。在JDK1.7中它是通过“锁分段”来保证线程安全的，本质上也是一个“可重入的互斥锁”（ReentrantLock）。多线程对同一个片段的访问，是互斥的；但是，对于不同片段的访问，却是可以同步进行的。在JDK1.8中是通过使用CAS原子更新、volatile关键字、synchronized可重入锁实现的。</li></ul><hr><p>Java中String不是基本类型，但是有些时候和基本类型差不多，如String b = “tao” ; 可以对变量直接赋值，而不用 new 一个对象（当然也可以用 new）。<br>Java中的变量和基本类型的值存放于栈内存，而new出来的对象本身存放于堆内存，指向对象的引用还是存放在栈内存。<br>栈内存的一个特点是数据共享,堆内存没有数据共享的特点</p><hr><p>下面程序的运行结果是 <strong>false</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;he&quot;</span> + <span class="keyword">new</span> String(<span class="string">&quot;llo&quot;</span>);</span><br><span class="line">System.err.println(str1 == str2);</span><br></pre></td></tr></table></figure><p><code>String str1= &quot;hello&quot;</code>,<code>String str2=&quot;he&quot;+&quot;llo&quot;</code>;之所以<code>str1==str2</code>返回true是因为两者都是在字符串常量池中（由于初始化就会在此区域分布内存）而常量池中的有个与栈区类似的特性，就是当str2指向的常量在常量区已存在时，他不会创建新的内存空间来存此常量，而是指向已有常量的内存（应该是以此节约空间），此时str1与str2这两个引用变量的值都是存”hello”的内存空间地址，但是<code>String str3= &quot;he&quot;+a;String a=&quot;llo&quot;;</code>时str1==str3返回的为false，是因为：str1指向的hello在编译期一如既往的还是分配在常量区内，a指向的llo也在常量区，虽然str3也是初始化但是编译器无法判断a这货到底是什么个情况，进而不会将str3的等号右侧声明在常量区内，而是在通过构造时在堆区中的非常量池外的内存中声明，至此str3与str1不止是分配内存的时期不同（一个在编译期，一个在运行期）而且在内存空间的区域也不同</p><hr><p>下列关于系列化和反序列化描述正确的是：</p><ul><li><strong>序列化是将数据转为n个 byte序列的过程</strong></li><li><strong>反序列化是将n个 byte转换为数据的过程</strong></li><li><del>将类型int转换为4 byte是反序列化过程</del></li><li><del>将8个字节转换为long类型的数据为序列化过程</del></li></ul><p>把你看得懂的转换为看不懂的，就是序列化。<br>把你看不懂的转换为看得懂的，就是反序列化。</p><hr><p>1、抽象类可以有构造，只不过不能new。<br>2、接口中可以有变量，但是无论你怎么写，最后都是public static final的。<br>3、抽象类中可以有静态方法，接口中也可以有。</p><p>扩展：<br>1、接口中可以有非抽象的方法，比如default方法（Java 1.8）。<br>2、接口中可以有带方法体的方法。（Java 1.8）<br>3、接口中的方法默认是public的。</p><hr><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">i++      先赋值在计算结果；</span><br><span class="line">++i      先计算结果再赋值。</span><br><span class="line">int i = 0;  </span><br><span class="line"><span class="code">       i = i ++;  // 左边这个i其实是障眼法，就是一个中间变量，可以和下行的i合并；</span></span><br><span class="line"><span class="code">       System.out.println(i);   这里等价于:</span></span><br><span class="line"><span class="code">int i = 0;</span></span><br><span class="line"><span class="code">       System.out.println(i++);   这下再看，先赋值(先将i传给println函数打印出来,在计算表达式结果)</span></span><br><span class="line"><span class="code">所以打印出来的是0，实际上整个表达式的结果已经是1了，只是没有打印出整个表达式的结果。</span></span><br><span class="line"><span class="code">所以我们知道如下结论：</span></span><br><span class="line"><span class="code">1、无论怎么变，i++和++i的整个表达式的结果都是1.</span></span><br><span class="line"><span class="code">2、有时我们打印的是表达式的结果(System.out.println(++i)),</span></span><br><span class="line"><span class="code">      有时我们打印的只是一个中间变量(System.out.println(i++))。</span></span><br><span class="line"><span class="code">Ps:</span></span><br><span class="line"><span class="code">int i = 0;  </span></span><br><span class="line"><span class="code">i++;</span></span><br><span class="line"><span class="code">System.out.println(i);  //值为1    打印的是表达式的结果</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">int i = 0;  </span></span><br><span class="line"><span class="code">++i;</span></span><br><span class="line"><span class="code">System.out.println(i);  //值为1     打印的是表达式的结果 </span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">int i = 0;  </span></span><br><span class="line"><span class="code">i = i++;</span></span><br><span class="line"><span class="code">System.out.println(i);  //值为0      打印的是中间变量(JVM中间缓存变量机制)</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">int i = 0;  </span></span><br><span class="line"><span class="code">i = ++i;</span></span><br><span class="line"><span class="code">System.out.println(i);  //值为1    打印的是表达式的结果</span></span><br></pre></td></tr></table></figure><hr><p>使用transient修饰的变量不会被序列化<br>对象序列化的所属类需要实现Serializable接口</p><hr><p><code>Math.ceil(-0.5)</code> <code>-0.0</code><br>ceil 方法上有这么一段注释：If the argument value is less than zero but greater than -1.0, then the result is negative zero<br>如果参数小于0且大于-1.0，结果为 -0</p><p><code>Math.floor(-0.5)</code> <code>-1.0</code><br>ceil 和 floor 方法 上都有一句话：If the argument is NaN or an infinity or positive zero or negative zero, then the result is the same as the argument，意思为：如果参数是 NaN、无穷、正 0、负 0，那么结果与参数相同，<br>如果是 -0.0，那么其结果是 -0.0</p><hr></div><section class="post-copyright"><p class="copyright-item"><span>Author:</span> <span>JiangHural</span></p><p class="copyright-item"><span>Permalink:</span> <span><a href="https://jianghural.github.io/2021/04/13/22-07-01/">https://jianghural.github.io/2021/04/13/22-07-01/</a></span></p><p class="copyright-item"><span>License:</span> <span>Copyright (c) 2021 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span></p><p class="copyright-item"><span>Slogan:</span> <span><strong>花有重开日，人无再少年。</strong></span></p></section><section class="post-tags"><div><span>Tag(s):</span> <span class="tag"><a href="/tags/Java/"># Java</a> <a href="/tags/%E7%89%9B%E5%AE%A2/"># 牛客</a></span></div><div><a href="javascript:window.history.back();">back</a> <span>· </span><a href="/">home</a></div></section><section class="post-nav"><a class="prev" rel="prev" href="/2021/04/14/22-32-41/">Git学习笔记</a> <a class="next" rel="next" href="/2021/04/12/08-44-06/">JDBC</a></section></article></div></div><footer id="footer" class="footer"><div class="copyright"><span>© JiangHural | AiWenLiang</span></div></footer></div></body></html>